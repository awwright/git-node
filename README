git node: Make Node.js submodules useful



HOW TO USE:

git node add <package> [<name>] [@<version>]: Install <package> as a Git repository URL or package name (resolve to URL by search engine)

git node update: Clone the appropriate dependencies or checkout latest compatible version

git node ls: List submodule packages

git node which <package>: Check if a package.json name or package identified by Git commit id is locally installed, and return its path



PACKAGE MAINTAINERS:

If your package is a library and you distribute it on npm, remember to add node_modules (or the appropriate packages) to `.npmignore`!

Remember to tag your Git repository according to the http://semver.org/spec/v1.0.0.html standard. Please remember to include the leading "v" in your version tags!

Please don't release 0.x.y versions of software. A major version of zero means it carries no semantics whatsoever, making it impossible to compare one package against another. Version numbers are cheap. The minute someone else is using your software, go ahead release version 1. Your software doesn't have to be perfect, you just have to tell people when you break stuff.

Place a symlink named "index.js" to your main library function in the root of your package. This lets people call require('submodulename') without too much extra work. While coding this in package.json also works, it doesn't carry the same semantics as index.js does.

Anytime you dereference an npm package, when initially adding by npm name, that package needs to be registered with the npm repository, and have a Git repository URL associated with it. Packages without a Git repository URL will need to have their clone URL manually specified.

Any packages your repository depends on should work without any additional configuration, since package-specific configurations (like the repository URL) are saved in `.gitmodules`.


CAVEATS:

Git tags are known on an open world basis, that is, we don't know for certain the complete set of tags, there may be some commits with a tag that we don't currently have because the push hasn't propogated. Developers will need to watch out if they add tags to old commits, especially if it's a buggy commit -- people depending on the repository may need to later blacklist the release/patch number as buggy.



What does git-node set out to do? Make the package multiverse slightly saner:

1. Central package repositories don't scale. I don't mean "you should have used sharding!" or technical bottlenecks. I mean, locking people into a particular service means you'll hit a hard ceiling on their number of users.
2. Listing dependencies by version number doesn't tell you anything meaningful about what you're depending on (semver is only meaningful with respect to other semver-labeled versions of the same package)
3. Checking in dependencies is a bad idea for the same reason (though slightly better if you're an application, at least you have all the dependency data with you)
4. npm is bloated
5. Node.js is bloated (with things like... npm)
6. Git submodules is a proper way of enumerating dependencies that a project uses, and probably the necessary way
7. But... git submodule isn't the best utility to work with, and is rather inflexible compared to Node.js's require system
8. git-node aims to make git learn about Node.js's dependency system so it can intellegently handle Node.js dependencies
